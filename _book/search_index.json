[
["index.html", "Optimization Notes 1 Introduction", " Optimization Notes Kasper Rosenkrands 19.09.2019 1 Introduction This book will include notes and exercises from the Optimization course at Aalborg University. "],
["lecture.html", "2 Lecture 2.1 Machine epsilon 2.2 Finding roots with search algorithms", " 2 Lecture 2.1 Machine epsilon The first exercise from this lecture was to write a program to determine the relative machine epsilon. # First we define a function that takes no input machine.eps &lt;- function() { # We guess that the machine epsilon is less than 1, so this is where we start eps &lt;- 1 # Then we want to add eps times one half and check if the result is neq 1 while (1 + eps / 2 != 1) { # If that is not the case we divide eps by 2 and check the condtion again eps &lt;- eps / 2 } # When the condition no longer hold our result is the relative machine # epsilon, i.e. the point where the computer can no longer distinguish 1 and 1 + eps return(eps) } machine.eps() ## [1] 2.220446e-16 2.2 Finding roots with search algorithms 2.2.1 Defining the objective function Then we defined a function. # The function is first defined f &lt;- function(x) {x^3 - x^2 - 1} Tested it for relevant values f(0) ## [1] -1 f(2) ## [1] 3 f(1.5) ## [1] 0.125 And plotted the output for the function a &lt;- 0 b &lt;- 2 curve(f, a, b) abline(h = 0, col = &quot;gray&quot;) We then went about finding the root of this function, first by naive search and thereafter using the bisectional method. 2.2.2 Naive search set.seed(1) x_candidate &lt;- runif(n = 1, a, b) x_candidate ## [1] 0.5310173 f_candidate &lt;- f(x_candidate) f_candidate ## [1] -1.132243 f_tolerance &lt;- 1e-5 naive_search &lt;- function() { iterations &lt;- 0 while (abs(f_candidate) &gt; f_tolerance) { x_candidate &lt;- runif(n = 1, a, b) f_candidate &lt;- f(x_candidate) iterations &lt;- iterations + 1 } cat( &quot;x candidate:\\t&quot;, x_candidate, &quot;\\t&quot;, &quot;f candidate:\\t&quot;, f_candidate, &quot;\\t&quot;, &quot;number of iterations:\\t&quot;, iterations) } naive_search() ## x candidate: 1.465572 f candidate: 1.327446e-06 number of iterations: 441550 2.2.3 Bisectional method bisection &lt;- function(f, a, b, tolerance = 1e-5, max_iterations = 1000) { iterations &lt;- 0 for (i in 1:max_iterations) { c &lt;- (a + b)/2 if (sign(f(a)) == sign(f(c))) { a &lt;- c } else { b &lt;- c } iterations &lt;- iterations + 1 if (abs(f(c)) &lt; tolerance){ break } } cat(&quot;Root:\\t&quot;, c, &quot;In:\\t&quot;, iterations, &quot;iterations&quot;) } bisection(f, 0, 2) ## Root: 1.465569 In: 18 iterations "]
]
